<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Privacy & Security Checker - Cover Your Tracks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            min-height: 100vh;
            color: #333;
        }

        .header {
            background: #2c3e50;
            color: white;
            padding: 30px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .scan-section {
            background: white;
            border-radius: 10px;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            text-align: center;
            margin-bottom: 40px;
        }

        .scan-button {
            display: inline-block;
            padding: 18px 40px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }

        .scan-button:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }

        .scan-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-container {
            display: none;
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .summary-card {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .summary-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
        }

        .summary-card.strong::before {
            background: #27ae60;
        }

        .summary-card.partial::before {
            background: #f39c12;
        }

        .summary-card.unique::before {
            background: #e74c3c;
        }

        .summary-card h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .summary-card .icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .summary-card.strong .icon {
            color: #27ae60;
        }

        .summary-card.partial .icon {
            color: #f39c12;
        }

        .summary-card.unique .icon {
            color: #e74c3c;
        }

        .detailed-results {
            background: white;
            border-radius: 10px;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
        }

        .result-section {
            margin-bottom: 40px;
        }

        .result-section h3 {
            font-size: 1.8rem;
            color: #2c3e50;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .fingerprint-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            margin-bottom: 10px;
            background: #fafafa;
            transition: all 0.2s ease;
        }

        .fingerprint-item:hover {
            background: #f5f5f5;
            border-color: #d0d0d0;
        }

        .fingerprint-item .name {
            font-weight: 600;
            color: #333;
        }

        .fingerprint-item .value {
            color: #666;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-width: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .fingerprint-item .bits {
            background: #e74c3c;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }

        .loading {
            text-align: center;
            padding: 60px;
        }

        .spinner {
            display: inline-block;
            width: 50px;
            height: 50px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #e74c3c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-fill {
            height: 100%;
            background: #e74c3c;
            width: 0%;
            transition: width 0.3s ease;
        }

        .info-box {
            background: #ecf0f1;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .info-box h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .recommendations {
            margin-top: 40px;
        }

        .recommendation-item {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 5px;
        }

        .recommendation-item h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .recommendation-item p {
            color: #666;
            line-height: 1.6;
        }

        .hash-display {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
            margin-top: 20px;
        }

        .hash-display .label {
            color: #95a5a6;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .container {
                padding: 20px 10px;
            }
            
            .scan-section {
                padding: 20px;
            }
            
            .detailed-results {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1>üõ°Ô∏è Npower Jita 2B Team 4</h1>
            <p>Test your browser to see how well you are protected from tracking and fingerprinting</p>
        </div>
    </div>

    <div class="container">
        <div class="scan-section">
            <h2>Test Your Browser</h2>
            <p style="margin: 20px 0; color: #666;">
                When you visit a website, your browser reveals information about you and your device. 
                This test shows you what information is visible and how unique your browser fingerprint is.
            </p>
            <button class="scan-button" onclick="runComprehensiveScan()">Test Your Browser</button>
        </div>

        <div class="loading" id="loading" style="display: none;">
            <div class="spinner"></div>
            <p style="font-size: 1.2rem; color: #666;">Analyzing your browser fingerprint...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="results-container" id="resultsContainer">
            <div class="summary-cards" id="summaryCards"></div>

            <div class="detailed-results">
                <div class="result-section">
                    <h3>üìä Your Browser Fingerprint</h3>
                    <div id="fingerprintDetails"></div>
                    <div class="hash-display">
                        <div class="label">Your unique fingerprint hash:</div>
                        <div id="fingerprintHash"></div>
                    </div>
                </div>

                <div class="result-section">
                    <h3>üîí Tracking Protection Analysis</h3>
                    <div id="protectionAnalysis"></div>
                </div>

                <div class="result-section">
                    <h3>üìç Location & Network Security</h3>
                    <div id="locationData"></div>
                </div>
                <div class="result-section recommendations">
                    <h3>üí° Recommendations</h3>
                    <div id="recommendations"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let fingerprintData = {};
        let protectionScore = 0;

        async function runComprehensiveScan() {
            const button = document.querySelector('.scan-button');
            const loading = document.getElementById('loading');
            const results = document.getElementById('resultsContainer');
            const progressFill = document.getElementById('progressFill');
            
            button.disabled = true;
            loading.style.display = 'block';
            results.style.display = 'none';
            progressFill.style.width = '0%';
            
            try {
                // Collect all fingerprinting data
                await collectFingerprintData(progressFill);
                
                // Analyze protection
                analyzeProtection();
                
                // Display results
                displayResults();
                
            } catch (error) {
                console.error('Scan error:', error);
            }
            
            loading.style.display = 'none';
            results.style.display = 'block';
            button.disabled = false;
        }

        async function collectFingerprintData(progressFill) {
            const tests = [
                { name: 'Basic Browser Info', fn: collectBasicInfo, weight: 10 },
                { name: 'Screen Information', fn: collectScreenInfo, weight: 10 },
                { name: 'Hardware Info', fn: collectHardwareInfo, weight: 15 },
                { name: 'Canvas Fingerprint', fn: collectCanvasFingerprint, weight: 15 },
                { name: 'WebGL Fingerprint', fn: collectWebGLFingerprint, weight: 15 },
                { name: 'Audio Fingerprint', fn: collectAudioFingerprint, weight: 10 },
                { name: 'Font Detection', fn: detectFonts, weight: 10 },
                { name: 'Plugin Information', fn: collectPluginInfo, weight: 5 },
                { name: 'Network Information', fn: collectNetworkInfo, weight: 5 },
                { name: 'Privacy Features', fn: detectPrivacyFeatures, weight: 5 }
            ];

            let progress = 0;
            for (const test of tests) {
                try {
                    await test.fn();
                } catch (e) {
                    console.error(`${test.name} failed:`, e);
                }
                progress += test.weight;
                progressFill.style.width = `${progress}%`;
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        }
        
        async function detectPrivacyFeatures() {
            // Detect Brave
            try {
                if (navigator.brave && await navigator.brave.isBrave()) {
                    fingerprintData.browser = 'Brave';
                    fingerprintData.braveDetected = true;
                }
            } catch (e) {
                fingerprintData.braveDetected = false;
            }
            
            // Detect ad blocking
            fingerprintData.adBlockDetected = await checkAdBlock();
            
            // Detect privacy-focused user agents
            const ua = navigator.userAgent.toLowerCase();
            fingerprintData.privacyBrowser = ua.includes('brave') || 
                                           ua.includes('duckduckgo') || 
                                           ua.includes('tor');
            
            // Check for privacy extensions indicators
            fingerprintData.privacyIndicators = {
                reducedTimerPrecision: checkTimerPrecision(),
                noPlugins: !navigator.plugins || navigator.plugins.length === 0,
                batteryAPIBlocked: !navigator.getBattery,
                webglMetadataHidden: checkWebGLMetadata()
            };
        }
        
        function checkWebGLMetadata() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl');
                if (!gl) return true; // WebGL blocked
                
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (!debugInfo) return true; // Debug info blocked
                
                const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                
                // Check if values are generic/spoofed
                return vendor === 'Google Inc.' && renderer === 'ANGLE';
            } catch (e) {
                return true;
            }
        }

        function collectBasicInfo() {
            fingerprintData.userAgent = navigator.userAgent;
            fingerprintData.language = navigator.language || navigator.userLanguage;
            fingerprintData.languages = navigator.languages ? navigator.languages.join(',') : 'not available';
            fingerprintData.platform = navigator.platform;
            fingerprintData.cookieEnabled = navigator.cookieEnabled;
            fingerprintData.doNotTrack = navigator.doNotTrack || navigator.msDoNotTrack || 'not set';
            fingerprintData.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            fingerprintData.timezoneOffset = new Date().getTimezoneOffset();
        }

        function collectScreenInfo() {
            fingerprintData.screenResolution = `${screen.width}x${screen.height}`;
            fingerprintData.screenColorDepth = screen.colorDepth;
            fingerprintData.screenPixelRatio = window.devicePixelRatio || 1;
            fingerprintData.availableScreenSize = `${screen.availWidth}x${screen.availHeight}`;
        }

        function collectHardwareInfo() {
            fingerprintData.hardwareConcurrency = navigator.hardwareConcurrency || 'not available';
            fingerprintData.deviceMemory = navigator.deviceMemory || 'not available';
            fingerprintData.maxTouchPoints = navigator.maxTouchPoints || 0;
        }

        function collectCanvasFingerprint() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 280;
            canvas.height = 60;
            
            ctx.fillStyle = '#f60';
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = '#069';
            ctx.font = '11pt Arial';
            ctx.fillText('Canvas fingerprint test üé®', 2, 15);
            ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
            ctx.font = '18pt Arial';
            ctx.fillText('BrowserLeaks.com', 4, 45);
            
            fingerprintData.canvas = canvas.toDataURL();
            fingerprintData.canvasHash = hashCode(fingerprintData.canvas);
        }

        function collectWebGLFingerprint() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (gl) {
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                fingerprintData.webglVendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : gl.getParameter(gl.VENDOR);
                fingerprintData.webglRenderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : gl.getParameter(gl.RENDERER);
                fingerprintData.webglVersion = gl.getParameter(gl.VERSION);
                fingerprintData.webglShadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
            } else {
                fingerprintData.webglVendor = 'not available';
                fingerprintData.webglRenderer = 'not available';
            }
        }

        async function collectAudioFingerprint() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    const context = new AudioContext();
                    const oscillator = context.createOscillator();
                    const analyser = context.createAnalyser();
                    const gain = context.createGain();
                    const scriptProcessor = context.createScriptProcessor(4096, 1, 1);
                    
                    gain.gain.value = 0;
                    oscillator.connect(analyser);
                    analyser.connect(scriptProcessor);
                    scriptProcessor.connect(gain);
                    gain.connect(context.destination);
                    
                    oscillator.start(0);
                    
                    await new Promise(resolve => {
                        scriptProcessor.onaudioprocess = function(event) {
                            const output = event.inputBuffer.getChannelData(0);
                            fingerprintData.audioFingerprint = hashCode(output.slice(0, 30).toString());
                            oscillator.stop();
                            context.close();
                            resolve();
                        };
                    });
                } else {
                    fingerprintData.audioFingerprint = 'not available';
                }
            } catch (e) {
                fingerprintData.audioFingerprint = 'error';
            }
        }

        function detectFonts() {
            const baseFonts = ['monospace', 'sans-serif', 'serif'];
            const testFonts = [
                'Arial', 'Arial Black', 'Comic Sans MS', 'Courier', 'Courier New',
                'Georgia', 'Helvetica', 'Impact', 'Times', 'Times New Roman',
                'Trebuchet MS', 'Verdana', 'Lucida Console', 'Tahoma', 'Calibri',
                'Consolas', 'Futura', 'Monaco', 'Optima', 'Palatino'
            ];
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = '72px monospace';
            const baseWidth = ctx.measureText('mmmmmmmmmmlli').width;
            
            const detectedFonts = [];
            testFonts.forEach(font => {
                let detected = false;
                baseFonts.forEach(baseFont => {
                    ctx.font = `72px '${font}', ${baseFont}`;
                    const width = ctx.measureText('mmmmmmmmmmlli').width;
                    if (width !== baseWidth) {
                        detected = true;
                    }
                });
                if (detected) {
                    detectedFonts.push(font);
                }
            });
            
            fingerprintData.fonts = detectedFonts.join(', ');
            fingerprintData.fontsCount = detectedFonts.length;
        }

        function collectPluginInfo() {
            const plugins = [];
            if (navigator.plugins) {
                for (let i = 0; i < navigator.plugins.length; i++) {
                    plugins.push(navigator.plugins[i].name);
                }
            }
            fingerprintData.plugins = plugins.join(', ') || 'none detected';
            fingerprintData.pluginsCount = plugins.length;
        }

        async function collectNetworkInfo() {
            // Check if we're on localhost
            const isLocalhost = window.location.hostname === 'localhost' || 
                               window.location.hostname === '127.0.0.1';
            
            if (isLocalhost) {
                fingerprintData.publicIP = 'localhost (deploy to see real IP)';
                fingerprintData.warning = 'Running on localhost - some tests may be inaccurate';
            } else {
                try {
                    // Get public IP and location info
                    const ipResponse = await fetch('https://httpbin.org/ip');
                    const ipData = await ipResponse.json();
                    fingerprintData.publicIP = ipData.origin;
                    
                    // Get detailed IP info including VPN detection
                    try {
                        const ipInfoResponse = await fetch(`https://ipapi.co/${ipData.origin}/json/`);
                        const ipInfo = await ipInfoResponse.json();
                        
                        fingerprintData.ipInfo = {
                            country: ipInfo.country_name || 'Unknown',
                            city: ipInfo.city || 'Unknown',
                            org: ipInfo.org || 'Unknown',
                            asn: ipInfo.asn || 'Unknown',
                            timezone: ipInfo.timezone || 'Unknown'
                        };
                        
                        // VPN detection based on multiple factors
                        fingerprintData.vpnDetection = detectVPN(ipInfo);
                        
                    } catch (e) {
                        console.error('IP info fetch failed:', e);
                        fingerprintData.ipInfo = { error: 'Unable to fetch detailed info' };
                    }
                    
                    // Additional VPN detection using timezone mismatch
                    fingerprintData.timezoneMismatch = checkTimezoneMismatch();
                    
                } catch (e) {
                    fingerprintData.publicIP = 'unable to detect';
                }
            }
            
            if (navigator.connection) {
                fingerprintData.connectionType = navigator.connection.effectiveType || 'unknown';
                fingerprintData.connectionDownlink = navigator.connection.downlink || 'unknown';
            }
            
            // Test for WebRTC IP leak
            try {
                await detectWebRTCLeak();
            } catch (e) {
                fingerprintData.webrtcIPs = 'unable to detect';
            }
        }
        
        function detectVPN(ipInfo) {
            const vpnIndicators = {
                hosting: false,
                vpnKeywords: false,
                datacenter: false,
                residentialMismatch: false
            };
            
            // Check if ISP/org contains VPN-related keywords
            const org = (ipInfo.org || '').toLowerCase();
            const vpnKeywords = ['vpn', 'proxy', 'hosting', 'datacenter', 'cloud', 'server', 
                                'digital ocean', 'amazon', 'google cloud', 'microsoft azure', 
                                'ovh', 'hetzner', 'linode', 'vultr'];
            
            vpnIndicators.vpnKeywords = vpnKeywords.some(keyword => org.includes(keyword));
            
            // Check for datacenter ASNs (common VPN providers)
            const datacenterASNs = ['AS13335', 'AS16276', 'AS14061', 'AS8075', 'AS16509', 
                                   'AS15169', 'AS8068', 'AS45090', 'AS20473'];
            vpnIndicators.datacenter = datacenterASNs.includes(ipInfo.asn);
            
            // Check if it's a hosting provider
            vpnIndicators.hosting = org.includes('hosting') || org.includes('datacenter') || 
                                   org.includes('cloud');
            
            // Calculate VPN probability
            const indicatorCount = Object.values(vpnIndicators).filter(Boolean).length;
            
            return {
                indicators: vpnIndicators,
                detected: indicatorCount >= 2,
                probability: indicatorCount >= 3 ? 'High' : indicatorCount >= 2 ? 'Medium' : 'Low',
                org: ipInfo.org,
                country: ipInfo.country_name
            };
        }
        
        function checkTimezoneMismatch() {
            // Compare browser timezone with IP-based timezone
            const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const ipTimezone = fingerprintData.ipInfo?.timezone;
            
            if (!ipTimezone || ipTimezone === 'Unknown') {
                return { checked: false };
            }
            
            // Check if timezones are significantly different
            const mismatch = browserTimezone !== ipTimezone;
            
            return {
                checked: true,
                mismatch: mismatch,
                browserTimezone: browserTimezone,
                ipTimezone: ipTimezone
            };
        }
        
        async function detectWebRTCLeak() {
            return new Promise((resolve) => {
                const ips = new Set();
                const privateIPs = new Set();
                const publicIPs = new Set();
                
                const pc = new RTCPeerConnection({
                    iceServers: [{urls: 'stun:stun.l.google.com:19302'}]
                });
                
                pc.createDataChannel('');
                pc.createOffer().then(offer => pc.setLocalDescription(offer));
                
                pc.onicecandidate = (event) => {
                    if (!event.candidate) {
                        const allIPs = Array.from(ips);
                        fingerprintData.webrtcIPs = allIPs.length > 0 ? allIPs.join(', ') : 'none detected';
                        fingerprintData.webrtcPrivateIPs = Array.from(privateIPs);
                        fingerprintData.webrtcPublicIPs = Array.from(publicIPs);
                        
                        // Check for VPN by comparing WebRTC IPs with public IP
                        if (publicIPs.size > 0 && fingerprintData.publicIP) {
                            fingerprintData.webrtcLeak = !Array.from(publicIPs).includes(fingerprintData.publicIP);
                        }
                        
                        pc.close();
                        resolve();
                        return;
                    }
                    
                    const regex = /([0-9]{1,3}\.){3}[0-9]{1,3}/g;
                    const matches = event.candidate.candidate.match(regex);
                    if (matches) {
                        matches.forEach(ip => {
                            ips.add(ip);
                            // Check if IP is private
                            if (ip.startsWith('10.') || ip.startsWith('172.') || 
                                ip.startsWith('192.168.') || ip.startsWith('127.')) {
                                privateIPs.add(ip);
                            } else {
                                publicIPs.add(ip);
                            }
                        });
                    }
                };
                
                setTimeout(() => {
                    const allIPs = Array.from(ips);
                    fingerprintData.webrtcIPs = allIPs.length > 0 ? allIPs.join(', ') : 'none detected';
                    fingerprintData.webrtcPrivateIPs = Array.from(privateIPs);
                    fingerprintData.webrtcPublicIPs = Array.from(publicIPs);
                    pc.close();
                    resolve();
                }, 2000);
            });
        }

        function hashCode(str) {
            let hash = 0;
            const string = String(str);
            for (let i = 0; i < string.length; i++) {
                const char = string.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(16);
        }

        function generateOverallFingerprint() {
            const data = JSON.stringify(fingerprintData);
            return hashCode(data);
        }

        function calculateBits(value, category) {
            // Simplified entropy calculation
            const commonValues = {
                userAgent: 10.5,
                language: 5.8,
                screenResolution: 7.2,
                timezone: 6.4,
                canvas: 11.8,
                webgl: 9.7,
                fonts: 8.3
            };
            
            return commonValues[category] || Math.random() * 5 + 3;
        }

        function analyzeProtection() {
            protectionScore = 0;
            const analysis = [];
            
            // Detect Brave Browser
            const isBrave = navigator.brave && navigator.brave.isBrave();
            if (isBrave) {
                protectionScore += 30;
                analysis.push({ name: 'Brave Browser Detected', status: 'Enhanced privacy protection', good: true });
            }
            
            // Check for tracking protection
            if (fingerprintData.doNotTrack === '1') {
                protectionScore += 10;
                analysis.push({ name: 'Do Not Track', status: 'enabled', good: true });
            } else {
                analysis.push({ name: 'Do Not Track', status: 'disabled', good: false });
            }
            
            // Check for fingerprinting resistance
            const fpResistance = checkFingerprintingResistance();
            if (fpResistance.resistant) {
                protectionScore += 25;
                analysis.push({ name: 'Fingerprinting Protection', status: fpResistance.status, good: true });
            } else {
                analysis.push({ name: 'Fingerprinting Protection', status: 'not detected', good: false });
            }
            
            // Check for WebRTC protection
            if (fingerprintData.webrtcIPs === 'none detected' || !fingerprintData.webrtcIPs) {
                protectionScore += 20;
                analysis.push({ name: 'WebRTC IP Protection', status: 'IPs hidden', good: true });
            } else if (fingerprintData.webrtcIPs.includes('local')) {
                protectionScore += 10;
                analysis.push({ name: 'WebRTC IP Protection', status: 'partial (local IPs only)', good: true });
            } else {
                analysis.push({ name: 'WebRTC IP Protection', status: 'IPs exposed', good: false });
            }
            
            // Check for canvas fingerprinting randomization
            const canvasProtection = checkCanvasProtection();
            if (canvasProtection) {
                protectionScore += 20;
                analysis.push({ name: 'Canvas Fingerprinting', status: 'randomized/blocked', good: true });
            } else {
                analysis.push({ name: 'Canvas Fingerprinting', status: 'not blocked', good: false });
            }
            
            // Check for third-party cookie blocking
            const thirdPartyCookies = checkThirdPartyCookieBlocking();
            if (thirdPartyCookies) {
                protectionScore += 15;
                analysis.push({ name: 'Third-party Cookies', status: 'blocked', good: true });
            } else {
                analysis.push({ name: 'Third-party Cookies', status: 'allowed', good: false });
            }
            
            // Check for VPN usage
            if (fingerprintData.vpnDetection?.detected) {
                protectionScore += 25;
                analysis.push({ name: 'VPN/Proxy Detected', status: `Active (${fingerprintData.vpnDetection.probability} probability)`, good: true });
            } else {
                analysis.push({ name: 'VPN/Proxy', status: 'Not detected', good: false });
            }
            
            // Check for timezone mismatch (another VPN indicator)
            if (fingerprintData.timezoneMismatch?.mismatch) {
                protectionScore += 10;
                analysis.push({ name: 'Location Privacy', status: 'Timezone mismatch detected (VPN likely)', good: true });
            }
            
            // Check for WebRTC leak while using VPN
            if (fingerprintData.webrtcLeak && fingerprintData.vpnDetection?.detected) {
                protectionScore -= 15;
                analysis.push({ name: 'WebRTC Leak', status: 'Real IP exposed despite VPN!', good: false });
            }
            
            // Check hardware spoofing
            if (fingerprintData.hardwareConcurrency === 2 || fingerprintData.hardwareConcurrency === 4) {
                protectionScore += 10;
                analysis.push({ name: 'Hardware Spoofing', status: 'possible spoofing detected', good: true });
            }
            
            fingerprintData.protectionAnalysis = analysis;
        }
        
        function checkFingerprintingResistance() {
            // Check for common fingerprinting resistance indicators
            const indicators = {
                // Timezone spoofing (UTC is common for privacy tools)
                timezoneUTC: fingerprintData.timezoneOffset === 0,
                // Common spoofed screen resolutions
                commonResolution: ['1920x1080', '1366x768', '1280x720'].includes(fingerprintData.screenResolution),
                // Reduced timer precision (privacy feature)
                reducedTimerPrecision: checkTimerPrecision(),
                // Limited plugin info
                noPlugins: fingerprintData.pluginsCount === 0,
                // Uniform color depth
                standardColorDepth: fingerprintData.screenColorDepth === 24
            };
            
            const resistanceCount = Object.values(indicators).filter(Boolean).length;
            
            if (resistanceCount >= 3) {
                return { resistant: true, status: 'Strong protection detected' };
            } else if (resistanceCount >= 2) {
                return { resistant: true, status: 'Moderate protection detected' };
            }
            return { resistant: false, status: 'No protection detected' };
        }
        
        function checkTimerPrecision() {
            // Check if performance.now() has reduced precision
            const timestamps = [];
            for (let i = 0; i < 10; i++) {
                timestamps.push(performance.now());
            }
            
            // Check if all timestamps end in .000 or have limited decimal places
            const limitedPrecision = timestamps.every(ts => {
                const decimal = (ts % 1).toFixed(3);
                return decimal === '0.000' || decimal.endsWith('00');
            });
            
            return limitedPrecision;
        }
        
        function checkCanvasProtection() {
            // Create multiple canvas samples to detect randomization
            const hashes = [];
            for (let i = 0; i < 3; i++) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.fillText('test', 2, 2);
                hashes.push(canvas.toDataURL());
            }
            
            // If hashes are different, canvas is being randomized
            const uniqueHashes = new Set(hashes);
            return uniqueHashes.size > 1;
        }
        
        function checkThirdPartyCookieBlocking() {
            // This is a simplified check - in reality, you'd need to test with actual third-party requests
            try {
                // Check if storage access API is available (indicates privacy features)
                if (document.hasStorageAccess) {
                    return true;
                }
                
                // Check for strict cookie settings
                if (navigator.cookieEnabled === false) {
                    return true;
                }
                
                return false;
            } catch (e) {
                return false;
            }
        }

        function displayResults() {
            // Display summary cards
            const summaryCards = document.getElementById('summaryCards');
            const fingerprintHash = generateOverallFingerprint();
            
            const protectionLevel = protectionScore > 30 ? 'strong' : protectionScore > 15 ? 'partial' : 'unique';
            const protectionText = protectionScore > 30 ? 'Strong Protection' : protectionScore > 15 ? 'Partial Protection' : 'Unique - Easily Trackable';
            const protectionIcon = protectionScore > 30 ? '‚úÖ' : protectionScore > 15 ? '‚ö†Ô∏è' : '‚ùå';
            
            // Display localhost warning if applicable
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                summaryCards.innerHTML = `
                    <div class="info-box" style="grid-column: 1 / -1; background: #fff3cd; border-color: #ffc107;">
                        <h4>‚ö†Ô∏è Localhost Testing Detected</h4>
                        <p>You're running this test on localhost. Some features won't work correctly:</p>
                        <ul style="margin-top: 10px; padding-left: 20px;">
                            <li>HTTPS-only APIs may be restricted</li>
                            <li>Third-party cookie detection won't work</li>
                            <li>Ad blocker detection may be inaccurate</li>
                            <li>Some fingerprinting vectors may be blocked</li>
                        </ul>
                        <p style="margin-top: 10px;"><strong>For accurate results, deploy this tool to a web server with HTTPS.</strong></p>
                    </div>
                ` + summaryCards.innerHTML;
            }
            
            summaryCards.innerHTML += `
                <div class="summary-card ${protectionLevel}">
                    <div class="icon">${protectionIcon}</div>
                    <h3>${protectionText}</h3>
                    <p>Your browser fingerprint appears to be ${protectionLevel === 'unique' ? 'unique among tested browsers' : 'somewhat protected from tracking'}</p>
                </div>
                <div class="summary-card partial">
                    <div class="icon">üîç</div>
                    <h3>Fingerprint Detected</h3>
                    <p>We detected ${Object.keys(fingerprintData).length} unique characteristics that can be used to track you</p>
                </div>
                <div class="summary-card ${navigator.cookieEnabled ? 'unique' : 'strong'}">
                    <div class="icon">${navigator.cookieEnabled ? 'üç™' : 'üõ°Ô∏è'}</div>
                    <h3>Cookie Status</h3>
                    <p>Cookies are ${navigator.cookieEnabled ? 'enabled and can be used for tracking' : 'disabled for better privacy'}</p>
                </div>
            `;
            
            // Display detailed fingerprint
            const fingerprintDetails = document.getElementById('fingerprintDetails');
            const importantFields = [
                { key: 'userAgent', name: 'User Agent', bits: calculateBits(fingerprintData.userAgent, 'userAgent') },
                { key: 'language', name: 'Language', bits: calculateBits(fingerprintData.language, 'language') },
                { key: 'screenResolution', name: 'Screen Resolution', bits: calculateBits(fingerprintData.screenResolution, 'screenResolution') },
                { key: 'timezone', name: 'Timezone', bits: calculateBits(fingerprintData.timezone, 'timezone') },
                { key: 'canvasHash', name: 'Canvas Fingerprint', bits: calculateBits(fingerprintData.canvasHash, 'canvas') },
                { key: 'webglRenderer', name: 'WebGL Renderer', bits: calculateBits(fingerprintData.webglRenderer, 'webgl') },
                { key: 'fonts', name: 'System Fonts', bits: calculateBits(fingerprintData.fonts, 'fonts') },
                { key: 'hardwareConcurrency', name: 'CPU Cores', bits: 4.2 },
                { key: 'deviceMemory', name: 'Device Memory', bits: 3.8 }
            ];
            
            fingerprintDetails.innerHTML = importantFields.map(field => `
                <div class="fingerprint-item">
                    <span class="name">${field.name}</span>
                    <span class="value">${fingerprintData[field.key] || 'not available'}</span>
                    <span class="bits">${field.bits.toFixed(1)} bits</span>
                </div>
            `).join('');
            
            document.getElementById('fingerprintHash').textContent = fingerprintHash;
            
            // Display protection analysis
            const protectionAnalysisDiv = document.getElementById('protectionAnalysis');
            protectionAnalysisDiv.innerHTML = fingerprintData.protectionAnalysis.map(item => `
                <div class="fingerprint-item">
                    <span class="name">${item.name}</span>
                    <span class="value">${item.status}</span>
                    <span class="bits" style="background: ${item.good ? '#27ae60' : '#e74c3c'}">${item.good ? 'Good' : 'Risk'}</span>
                </div>
            `).join('');
            
            // Display location and network data
            const locationData = document.getElementById('locationData');
            const vpnStatus = fingerprintData.vpnDetection?.detected ? 
                `VPN/Proxy Active (${fingerprintData.vpnDetection.probability} probability)` : 
                'No VPN/Proxy detected';
            
            const vpnStatusColor = fingerprintData.vpnDetection?.detected ? 'safe' : 'warning';
            
            locationData.innerHTML = `
                <div class="fingerprint-item">
                    <span class="name">Public IP Address</span>
                    <span class="value">${fingerprintData.publicIP}</span>
                    <span class="bits" style="background: #e74c3c">Exposed</span>
                </div>
                <div class="fingerprint-item">
                    <span class="name">VPN/Proxy Status</span>
                    <span class="value">${vpnStatus}</span>
                    <span class="bits" style="background: ${vpnStatusColor === 'safe' ? '#27ae60' : '#e74c3c'}">${vpnStatusColor === 'safe' ? 'Protected' : 'Unprotected'}</span>
                </div>
                ${fingerprintData.ipInfo ? `
                <div class="fingerprint-item">
                    <span class="name">ISP/Organization</span>
                    <span class="value">${fingerprintData.ipInfo.org || 'Unknown'}</span>
                    <span class="bits" style="background: ${fingerprintData.vpnDetection?.detected ? '#27ae60' : '#f39c12'}">${fingerprintData.vpnDetection?.detected ? 'VPN Provider' : 'ISP'}</span>
                </div>
                <div class="fingerprint-item">
                    <span class="name">Location</span>
                    <span class="value">${fingerprintData.ipInfo.city || 'Unknown'}, ${fingerprintData.ipInfo.country || 'Unknown'}</span>
                    <span class="bits" style="background: #f39c12">Visible</span>
                </div>
                ` : ''}
                ${fingerprintData.timezoneMismatch?.checked ? `
                <div class="fingerprint-item">
                    <span class="name">Timezone Check</span>
                    <span class="value">${fingerprintData.timezoneMismatch.mismatch ? 'Mismatch detected' : 'Timezone matches IP location'}</span>
                    <span class="bits" style="background: ${fingerprintData.timezoneMismatch.mismatch ? '#27ae60' : '#e74c3c'}">${fingerprintData.timezoneMismatch.mismatch ? 'VPN Likely' : 'Normal'}</span>
                </div>
                ` : ''}
                <div class="fingerprint-item">
                    <span class="name">WebRTC IPs</span>
                    <span class="value">${fingerprintData.webrtcIPs || 'None detected'}</span>
                    <span class="bits" style="background: ${fingerprintData.webrtcIPs === 'none detected' ? '#27ae60' : '#e74c3c'}">${fingerprintData.webrtcIPs === 'none detected' ? 'Hidden' : 'Exposed'}</span>
                </div>
                ${fingerprintData.webrtcLeak !== undefined ? `
                <div class="fingerprint-item">
                    <span class="name">WebRTC Leak Test</span>
                    <span class="value">${fingerprintData.webrtcLeak ? 'IP mismatch - possible leak!' : 'No leak detected'}</span>
                    <span class="bits" style="background: ${fingerprintData.webrtcLeak ? '#e74c3c' : '#27ae60'}">${fingerprintData.webrtcLeak ? 'Leak!' : 'Safe'}</span>
                </div>
                ` : ''}
            `;
            
            // Display recommendations
            const recommendations = document.getElementById('recommendations');
            const recommendationsList = [
                {
                    title: 'Use Privacy-Focused Browser',
                    description: 'Consider using browsers like Firefox with enhanced tracking protection, Brave, or Tor Browser for maximum privacy.'
                },
                {
                    title: 'Install Privacy Extensions',
                    description: 'Use extensions like uBlock Origin, Privacy Badger, or Canvas Blocker to prevent fingerprinting and tracking.'
                },
                {
                    title: 'Disable WebRTC',
                    description: 'WebRTC can leak your real IP address even when using a VPN. Consider disabling it in your browser settings.'
                },
                {
                    title: 'Use a VPN',
                    description: 'A VPN can help mask your IP address and location, making it harder to track you across websites.'
                }
            ];
            
            recommendations.innerHTML = recommendationsList.map(rec => `
                <div class="recommendation-item">
                    <h4>${rec.title}</h4>
                    <p>${rec.description}</p>
                </div>
            `).join('');
        }
    </script>
</body>
</html>
